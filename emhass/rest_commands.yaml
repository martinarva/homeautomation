rest_command:
  publish_data:
    url: http://192.168.1.35:5001/action/publish-data
    method: POST
    content_type: 'application/json'
    timeout: 60
    payload: '{}'
    
  naive_mpc_optim_15min:
    url: http://192.168.1.35:5001/action/naive-mpc-optim
    method: POST
    content_type: 'application/json'
    timeout: 60
    payload: >-
      {% set tz = now().tzinfo %}
      {% set now_ts = now().astimezone(tz) %}
      {% set L = state_attr('sensor.nordpool_15_min_import_pyscript','raw_all') or [] %}
      {% set P = state_attr('sensor.nordpool_15_min_export_pyscript','raw_all')  or [] %}
      {% set n = [L|length, P|length]|min %}

      {# find the slot that contains "now" #}
      {% set idx = namespace(i=-1) %}
      {% for i in range(n) %}
        {% set s = as_datetime(L[i].start).astimezone(tz) %}
        {% set e = as_datetime(L[i].end).astimezone(tz) %}
        {% if now_ts >= s and now_ts < e %}
          {% set idx.i = i %}
        {% endif %}
      {% endfor %}

      {# hard-fail if no current slot #}
      {% if idx.i == -1 %}{{ 1/0 }}{% endif %}

      {% set load_vals = L[idx.i:n] | map(attribute='value') | list %}
      {% set prod_vals = P[idx.i:n] | map(attribute='value') | list %}

      {% set load_pad = load_vals[-1] %}
      {% set prod_pad = prod_vals[-1] %}
      {% set forecast_len = (load_vals|length) + 12 %}

      {
        "load_cost_forecast": {{ load_vals + [load_pad]*12 }},
        "prod_price_forecast": {{ prod_vals + [prod_pad]*12 }},
        "prediction_horizon": {{ forecast_len }},
        "model_type": "load_forecast",
        "pv_power_forecast": {{
          [states('sensor.total_pv_power') | int(0)] +
          state_attr('sensor.solcast_pv_combined_forecast_15min', 'detailedForecast')
          | selectattr('period_start', 'gt', utcnow().isoformat())
          | map(attribute='pv_estimate')
          | map('multiply', 1000)
          | map('int')
          | list
        }},
        "soc_init": {{
          [((states('sensor.ss_battery_soc') | int(0)) / 100), 0] | max
        }},
        "battery_target_state_of_charge": {{
          (states('input_number.final_soc') | float(0) / 100)
        }},
        "battery_minimum_state_of_charge": {{
          (
            min(
              (states('input_number.emhass_min_soc') | float(0) / 100),
              (states('sensor.ss_battery_soc') | float(0) / 100)
            )
          )
        }},

        "battery_maximum_state_of_charge": {{
          (
            max(
              (states('input_number.emhass_max_soc') | float(0) / 100),
              (states('sensor.ss_battery_soc') | float(0) / 100)
            )
          )
        }},
        "operating_hours_of_each_deferrable_load": [{{ (states('sensor.i3s_94_estimated_charge_time') | int(0)) }}, {{ (states('sensor.pool_heating_hours_needed') | int(0)) }}, 0],
        "nominal_power_of_deferrable_loads": [{{ (states('input_number.bmw_i3s_charger_power') | int(0)) }}, 9650, 0],
        "end_timesteps_of_each_deferrable_load": [{{ (states('sensor.i3s_hours_until_departure') | int(0)) * 4 }}, {{ (states('sensor.pool_on_time_end_timestep_to_emhass') | int(0)) * 4 }}, 0],
        "def_current_state": [{{ iif(states('sensor.p_deferrable0')|int(0), 1, 0) }}, {{ iif(states('sensor.p_deferrable1')|int(0), 1, 0) }}, 0],
        "var_model": "sensor.ss_load_power_without_deferrable",
        "alpha": 0.2,
        "beta": 0.8
      }

  ml_forecast_model_fit:
    url: http://192.168.1.35:5001/action/forecast-model-fit
    method: POST
    content_type: 'application/json'
    timeout: 60
    payload: >-
      {
        "days_to_retrieve": 20,
        "model_type": "load_forecast",
        "var_model": "sensor.ss_load_power_without_deferrable",
        "sklearn_model": "KNeighborsRegressor",
        "num_lags": 192,
        "split_date_delta": "48h",
        "perform_backtest": "True"
      }
